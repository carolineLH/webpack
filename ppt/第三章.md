## 1. 自动清理构建目录产物
* 避免构建前每次都需要手动删除dist,使用`clean-wepack-plugin`,这个插件默认会删除`output`指定的输出目录。
* 使用方法：
```js
// 第一步，安装 npm install --save-dev clean-webpack-plugin
// 第二步：引入const CleanWebpackPlugin = require('clean-webpack-plugin')
// 第三步：加到插件数组里面去。在plugin数组中加上new CleanWebpackPlugin()
```
## 2. PostCSS插件autoprefixer自动补齐CSS3前缀
* 使用autoprefixer插件可以实现前缀的自动补齐。autoprefixer插件是后处理器，也就是说在代码生成完了之后再给添加前缀。
* 通常还是会结合`postcss-loader`插件一起使用。
```js
// 在配置文件中，在module中的rule中加上
{
        test: /.less$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          'less-loader',
          {
            loader: 'postcss-loader',
            options: {
              plugins: () => [
                require('autoprefixer')({
                  browsers: ['last 2 version', '>1%', 'ios 7']
                })
              ]
            }
          }
        ]
      },
```
## 3. 移动端CSS px自动转换成rem
* 以前适配方法： 1. css媒体查询实现响应式布局：缺陷：需要些多套适配样式代码;
* rem是什么？
```
W3C对rem的定义：font-size of the root element

rem和px的对比：rem是相对单位；px是绝对单位。

```
* 使用`px2rem-loader`将px转换成rem，页面渲染时计算根元素的`font-size`的值(可以使用手淘的`lib-flexible`库)。
* 使用方法：
```js
// 第一步：在配置文件中,加上这个loader
 {
  loader: 'px2rem-loader',
  options: {
    remUnit: 75,
    remPrecision: 8
  }
}
// 第二步：在index.html文件中引入`lib-flexible.js`的代码
```

## 4. 静态资源内联
* 资源内联的意义：
```
1. 代码层面：
 页面框架的初始化脚本
 上报相关打点
 css内联避免页面闪动

2. 请求层面：减少HTTP网络请求数
 小图片或者字体内联(url-loader)
```

* HTML和JS内联： 用`raw-loader`,注意版本，最新版本有点问题
* CSS内联：方案一：借助`style-loader`，方案二：`html-inline-css-webpack-plugin`使用内联的时候要使用ejs语法插入

## 5.多页面应用打包通用方案
* 多页面应用(MPA)概念：每一次页面跳转的时候，后台服务器都会给返回一个新的html文档，这种病类型的网站也就是多页网站，也叫作多页应用。每个页面是解耦的，seo更友好。
* 思路：动态获取entry和设置`html-webpack-plugin`数量。利用glob.sync去引入入口。
```js
// 第一步：将所有的页面都放到相应的文件夹下面
// 第二步：安装glob库
// 第三步：在配置文件中修改配置

// 生成entry和htmlWebpackPlugins
const setMPA = () => {
  const entry = {}
  const htmlWebpackPlugins = []
  const entryFiles = glob.sync(path.join(__dirname, './src/*/index.js'))

  Object.keys(entryFiles).map(index => {
    const entryFile = entryFiles[index]

    const match = entryFile.match(/src\/(.*)\/index\.js/)
    const pageName = match && match[1]

    entry[pageName] = entryFile;
    htmlWebpackPlugins.push(
      new HtmlWebpackPlugin({
        template: path.join(__dirname, `src/${pageName}/index.html`),
        filename: `${pageName}.html`,
        chunks: [pageName],
        inject: true,
        minify: {
          html5: true,
          collapseWhitespace: true,
          preserveLineBreaks: false,
          minifyCSS: true,
          minifyJS: true,
          removeComments: false
        }
      })
    )
  })
  return {
    entry,
    htmlWebpackPlugins
  }
}

module.exports = {
  entry: entry,
  plugins: [].concat(htmlWebpackPlugins)
}
```

## 6.使用source map
* webpack最终会打包成一个bundle文件(一个大的js文件)
* source map科普文，[点这里](http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html)
* 开发环境开启，线上环境关闭
* source map关键字：
```js
eval: 使用eval包裹的模块代码
source map: 产生.map文件
cheap: 不包含列信息
inline: 将.map作为DataURI嵌入，不单独生成.map文件
module: 包含loader的sourcemap
```
* source map的调试运用：在配置文件中，通过devtool选项来控制

## 7. 提取页面公共资源
* 利用`SplitChunksPlugin`进行公共脚本分离。`SplitChunksPlugin`是webpack4内置的，替代`CommonsChunkPlugin`插件。
* chunks参数说明：
```js
async异步引入的库进行分离（默认）
initial同步引入的库进行分离
all所有引入的库进行分离（推荐）
```
* 基础库分离：使用`html-webpack-externals-plugin`。具体使用如下：
```js
// 第一步：安装html-webpack-externals-plugin插件
// 第二步：在配置文件中
const HtmlWebpackExternalsPlugin = require('html-webpack-externals-plugin')

  new HtmlWebpackExternalsPlugin({
    externals: [
      {
        module: 'react',
        entry: 'https://unpkg.com/react@16/umd/react.production.min.js',
        global: 'React',
      },
      {
        module: 'react-dom',
        entry: 'https://unpkg.com/react-dom@16/umd/react-dom.production.min.js',
        global: 'ReactDOM',
      },
    ],
  })
```
* 利用`SplitChunksPlugin`分离基础包，用test，具体做法是根据文档来配置
* 利用`SplitChunksPlugin`分离页面公共文件，`minChunks`设置最小引用次数为2次，`minuSize`分离的包体积的大小。具体做法是根据文档来配置。

## 8.tree shaking（摇树优化）
* 在webpack4已经默认支持了。在`.babelrc`里设置`module:false`即可。`mode: production`的情况下默认开启。
* `tree shaking`就是只把用到的方法打入bundle，没用到的方法会在uglify阶段被擦除掉。
* **必须是ES6的语法，CJS的方式不支持**。
* DCE(Elimination)指的是：
```
代码不会被执行，不可到达
代码执行的结果不会被用到
代码只会影响死变量（只写不读）

```
* Tree-shaking原理：本质还是对代码进行静态的分析。把一些DCE的代码在uglify阶段删除掉。

## 9. Scope Hoisting使用和原理分析
* webpack的模块机制：
```
打包出来的是一个IIFE（匿名闭包）
modules是一个数组，每一项是一个模块初始化函数
__webapck_require用来加载模块，返回module.exports
通过WEBPACK_REQUIRE_METHOD(O)启动程序
```
* `scope hoisting`原理: 将所有模块的代码按照引用顺序放在一个函数作用域李，然后适当的重命名一些变量以防止变量名冲突。通过`scope hoisting`可以减少函数声明代码和内存开销。

## 10. 代码分割和动态import
* 代码分割的意义，对于大的web应用来讲，将所有的代码都放在一个文件中显然是不够有效的，特别是当你的某些代码块是在某些特殊的时候才会被使用到。webpack有一个功能就是讲你的代码库分割成chunks（语块），当代码运行到需要他们的时候在进行加载。
* 代码分割适用的场景：抽离相同的代码到一个共享块；脚本懒加载，使得初始下载的代码更小。
* 懒加载JS脚本的方式：
```js
  CommonJS: require.ensure
  ES6: **动态** import（目前还没有原生支持，需要babel转换）
```
* 如何使用动态import？
```js
1. 安装babel插件: npm install @babel/plugin-syntax-dynamic-import -D
2. ES6：动态import，在.babelrc文件中，插入如下代码
{
  "plugins": ["@babel/plugin-syntax-dynamic-import"],
  ...
}
```

## 11.在webpack中使用ESLint
* 制定团队的ESLint规范遵循规则：
```js
1. 不重复造轮子，基于eslint:recommend配置并改进
2. 能够帮助发现代码错误的规则，全部开启
3. 帮助保持团队的代码风格统一，而不是限制开发体验
```
* ESLint如何执行落地？1.和CI/CD系统集成；2.和webpack集成
* webpack与ESLint集成，使用`eslint-loader`,构建时进行JS检查





