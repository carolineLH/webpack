## 1. 自动清理构建目录产物
* 避免构建前每次都需要手动删除dist,使用`clean-wepack-plugin`,这个插件默认会删除`output`指定的输出目录。
* 使用方法：
```js
// 第一步，安装 npm install --save-dev clean-webpack-plugin
// 第二步：引入const CleanWebpackPlugin = require('clean-webpack-plugin')
// 第三步：加到插件数组里面去。在plugin数组中加上new CleanWebpackPlugin()
```
## 2. PostCSS插件autoprefixer自动补齐CSS3前缀
* 使用autoprefixer插件可以实现前缀的自动补齐。autoprefixer插件是后处理器，也就是说在代码生成完了之后再给添加前缀。
* 通常还是会结合`postcss-loader`插件一起使用。
```js
// 在配置文件中，在module中的rule中加上
{
        test: /.less$/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          'less-loader',
          {
            loader: 'postcss-loader',
            options: {
              plugins: () => [
                require('autoprefixer')({
                  browsers: ['last 2 version', '>1%', 'ios 7']
                })
              ]
            }
          }
        ]
      },
```
## 3. 移动端CSS px自动转换成rem
* 以前适配方法： 1. css媒体查询实现响应式布局：缺陷：需要些多套适配样式代码;
* rem是什么？
```
W3C对rem的定义：font-size of the root element

rem和px的对比：rem是相对单位；px是绝对单位。

```
* 使用`px2rem-loader`将px转换成rem，页面渲染时计算根元素的`font-size`的值(可以使用手淘的`lib-flexible`库)。
* 使用方法：
```js
// 第一步：在配置文件中,加上这个loader
 {
  loader: 'px2rem-loader',
  options: {
    remUnit: 75,
    remPrecision: 8
  }
}
// 第二步：在index.html文件中引入`lib-flexible.js`的代码
```

## 4. 静态资源内联
* 资源内联的意义：
```
1. 代码层面：
 页面框架的初始化脚本
 上报相关打点
 css内联避免页面闪动

2. 请求层面：减少HTTP网络请求数
 小图片或者字体内联(url-loader)
```

* HTML和JS内联： 用`raw-loader`,注意版本，最新版本有点问题
* CSS内联：方案一：借助`style-loader`，方案二：`html-inline-css-webpack-plugin`使用内联的时候要使用ejs语法插入

## 5.多页面应用打包通用方案
* 多页面应用(MPA)概念：每一次页面跳转的时候，后台服务器都会给返回一个新的html文档，这种病类型的网站也就是多页网站，也叫作多页应用。每个页面是解耦的，seo更友好。
* 思路：动态获取entry和设置`html-webpack-plugin`数量。利用glob.sync去引入入口。
```js
// 第一步：将所有的页面都放到相应的文件夹下面
// 第二步：安装glob库
// 第三步：在配置文件中修改配置

// 生成entry和htmlWebpackPlugins
const setMPA = () => {
  const entry = {}
  const htmlWebpackPlugins = []
  const entryFiles = glob.sync(path.join(__dirname, './src/*/index.js'))

  Object.keys(entryFiles).map(index => {
    const entryFile = entryFiles[index]

    const match = entryFile.match(/src\/(.*)\/index\.js/)
    const pageName = match && match[1]

    entry[pageName] = entryFile;
    htmlWebpackPlugins.push(
      new HtmlWebpackPlugin({
        template: path.join(__dirname, `src/${pageName}/index.html`),
        filename: `${pageName}.html`,
        chunks: [pageName],
        inject: true,
        minify: {
          html5: true,
          collapseWhitespace: true,
          preserveLineBreaks: false,
          minifyCSS: true,
          minifyJS: true,
          removeComments: false
        }
      })
    )
  })
  return {
    entry,
    htmlWebpackPlugins
  }
}

module.exports = {
  entry: entry,
  plugins: [].concat(htmlWebpackPlugins)
}
```

## 6.使用source map
* webpack最终会打包成一个bundle文件(一个大的js文件)
* source map科普文，[点这里](http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html)
* 开发环境开启，线上环境关闭
* source map关键字：
```js
eval: 使用eval包裹的模块代码
source map: 产生.map文件
cheap: 不包含列信息
inline: 将.map作为DataURI嵌入，不单独生成.map文件
module: 包含loader的sourcemap
```
* source map的调试运用：在配置文件中，通过devtool选项来控制

## 7. 提取页面公共资源




